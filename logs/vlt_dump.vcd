$version Generated by VerilatedVcd $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire  1 8! clk $end
  $scope module top $end
   $var wire  1 8! clk $end
   $scope module cpu_item $end
    $var wire 32 ( alu_b [31:0] $end
    $var wire  1 4 alu_b_ctr $end
    $var wire  4 . alu_ctr [3:0] $end
    $var wire  1 9 alu_less $end
    $var wire 32 ) alu_out [31:0] $end
    $var wire  1 : alu_zero $end
    $var wire  1 ; branch_ture $end
    $var wire  4 / bxx [3:0] $end
    $var wire  1 8! clk $end
    $var wire 32 - data2reg [31:0] $end
    $var wire 32 - data2reg_wire [31:0] $end
    $var wire  3 2 data_mem_opr [2:0] $end
    $var wire  4 0 data_mem_opw [3:0] $end
    $var wire 32 * data_mem_rdata [31:0] $end
    $var wire 32 ' imm [31:0] $end
    $var wire 32 $ instr [31:0] $end
    $var wire  1 5 jal $end
    $var wire 32 , jal_branch_pc [31:0] $end
    $var wire  1 6 jalr $end
    $var wire  3 1 mem2reg [2:0] $end
    $var wire  1 8 mem_we $end
    $var wire 32 + normal_pc [31:0] $end
    $var wire 32 # pc [31:0] $end
    $var wire  2 3 pc_cond [1:0] $end
    $var wire  1 7 reg_we $end
    $var wire 32 % rs1_data [31:0] $end
    $var wire 32 & rs2_data [31:0] $end
    $scope module alu_temp $end
     $var wire 32 % a [31:0] $end
     $var wire  1 M add_cin $end
     $var wire  1 O add_sub $end
     $var wire 32 ( b [31:0] $end
     $var wire  4 . ctr [3:0] $end
     $var wire  1 < is_add $end
     $var wire  1 C is_and $end
     $var wire  1 9 is_less $end
     $var wire  1 B is_or $end
     $var wire  1 > is_set_lt $end
     $var wire  1 ? is_set_ltu $end
     $var wire  1 = is_shift_l $end
     $var wire  1 A is_shift_r $end
     $var wire  1 E is_shift_ra $end
     $var wire  1 D is_sub $end
     $var wire  1 @ is_xor $end
     $var wire  1 : is_zero $end
     $var wire 32 ) out [31:0] $end
     $var wire 32 F out_add [31:0] $end
     $var wire 32 J out_and [31:0] $end
     $var wire  1 K out_carry $end
     $var wire  1 9 out_less $end
     $var wire 32 I out_or [31:0] $end
     $var wire  1 L out_overflow $end
     $var wire 32 G out_shift [31:0] $end
     $var wire 32 ) out_temp [31:0] $end
     $var wire 32 H out_xor [31:0] $end
     $var wire  1 : out_zero $end
     $var wire  1 Q set_l $end
     $var wire  1 P shift_lr $end
     $var wire  2 N shift_type [1:0] $end
     $scope module item0 $end
      $var wire 32 % data_in [31:0] $end
      $var wire 32 G data_out [31:0] $end
      $var wire  5 R shift_amt [4:0] $end
      $var wire  2 N shift_type [1:0] $end
      $var wire 32 S stage1 [31:0] $end
      $var wire 32 T stage2 [31:0] $end
      $var wire 32 U stage3 [31:0] $end
      $var wire 32 V stage4 [31:0] $end
      $var wire 32 G stage5 [31:0] $end
     $upscope $end
     $scope module item_add $end
      $var wire 32 % a [31:0] $end
      $var wire 32 W b [31:0] $end
      $var wire  1 K carry $end
      $var wire  1 M cin $end
      $var wire  1 L overflow $end
      $var wire 32 F sum [31:0] $end
      $var wire  1 : zero $end
     $upscope $end
     $scope module item_alu_decode $end
      $var wire  4 . alu_ctr [3:0] $end
      $var wire  1 < is_add $end
      $var wire  1 C is_and $end
      $var wire  1 B is_or $end
      $var wire  1 > is_set_lt $end
      $var wire  1 ? is_set_ltu $end
      $var wire  1 = is_shift_l $end
      $var wire  1 A is_shift_r $end
      $var wire  1 E is_shift_ra $end
      $var wire  1 D is_sub $end
      $var wire  1 @ is_xor $end
     $upscope $end
    $upscope $end
    $scope module ctr_item $end
     $var wire  1 4 alu_b_ctr $end
     $var wire  4 . alu_ctr [3:0] $end
     $var wire  4 . alu_ctr_temp [3:0] $end
     $var wire  4 / bxx [3:0] $end
     $var wire  3 2 data_mem_opr [2:0] $end
     $var wire  4 0 data_mem_opw [3:0] $end
     $var wire  4 0 data_mem_opw_temp [3:0] $end
     $var wire  3 2 fun3 [2:0] $end
     $var wire  1 g fun3_000 $end
     $var wire  1 h fun3_001 $end
     $var wire  1 i fun3_010 $end
     $var wire  1 j fun3_011 $end
     $var wire  1 k fun3_100 $end
     $var wire  1 l fun3_101 $end
     $var wire  1 m fun3_110 $end
     $var wire  1 n fun3_111 $end
     $var wire  7 Y fun7 [6:0] $end
     $var wire 32 ' imm [31:0] $end
     $var wire 32 ] immB [31:0] $end
     $var wire 32 Z immI [31:0] $end
     $var wire 32 ^ immJ [31:0] $end
     $var wire 32 \ immS [31:0] $end
     $var wire 32 [ immU [31:0] $end
     $var wire 32 $ instr [31:0] $end
     $var wire  1 5 jal $end
     $var wire  1 6 jalr $end
     $var wire  3 1 mem2reg [2:0] $end
     $var wire  3 1 mem2reg_temp [2:0] $end
     $var wire  1 8 mem_we $end
     $var wire  7 X op [6:0] $end
     $var wire  1 e op_0000_011 $end
     $var wire  1 f op_0010_011 $end
     $var wire  1 d op_0010_111 $end
     $var wire  1 8 op_0100_011 $end
     $var wire  1 b op_0110_011 $end
     $var wire  1 c op_0110_111 $end
     $var wire  1 ` op_1100_011 $end
     $var wire  1 6 op_1100_111 $end
     $var wire  1 5 op_1101_111 $end
     $var wire 32 ' out_imm [31:0] $end
     $var wire  1 7 reg_we $end
     $var wire  1 ` type_B $end
     $var wire  1 a type_I $end
     $var wire  1 5 type_J $end
     $var wire  1 b type_R $end
     $var wire  1 8 type_S $end
     $var wire  1 _ type_U $end
    $upscope $end
    $scope module data_memory_item $end
     $var wire 32 9! ADDR_WIDTH [31:0] $end
     $var wire 32 :! DATA_WIDTH [31:0] $end
     $var wire 15 o addr [14:0] $end
     $var wire  4 0 be [3:0] $end
     $var wire  1 8! clk $end
     $var wire  3 2 op_read [2:0] $end
     $var wire 32 * rdata [31:0] $end
     $var wire 32 p rdata_reg [31:0] $end
     $var wire 32 * rdata_temp [31:0] $end
     $var wire 32 & wdata [31:0] $end
     $var wire  1 8 we $end
    $upscope $end
    $scope module instr_memory_item $end
     $var wire 32 ;! ADDR_WIDTH [31:0] $end
     $var wire 32 :! DATA_WIDTH [31:0] $end
     $var wire 16 q addr [15:0] $end
     $var wire 32 $ instr [31:0] $end
    $upscope $end
    $scope module pc_branch_item $end
     $var wire  4 / branch [3:0] $end
     $var wire  1 ; branch_ture $end
     $var wire  1 r branch_ture_temp $end
     $var wire  1 9 less $end
     $var wire  1 : zero $end
    $upscope $end
    $scope module pc_item $end
     $var wire 32 ) alu_out [31:0] $end
     $var wire  1 8! clk $end
     $var wire  2 3 cond [1:0] $end
     $var wire 32 ' imm [31:0] $end
     $var wire 32 , jal_branch_pc [31:0] $end
     $var wire 32 # next_pc [31:0] $end
     $var wire 32 + normal_pc [31:0] $end
     $var wire 32 # pc [31:0] $end
    $upscope $end
    $scope module regfile_item $end
     $var wire  1 8! clk $end
     $var wire  5 u rd [4:0] $end
     $var wire 32 v register[0] [31:0] $end
     $var wire 32 "! register[10] [31:0] $end
     $var wire 32 #! register[11] [31:0] $end
     $var wire 32 $! register[12] [31:0] $end
     $var wire 32 %! register[13] [31:0] $end
     $var wire 32 &! register[14] [31:0] $end
     $var wire 32 '! register[15] [31:0] $end
     $var wire 32 (! register[16] [31:0] $end
     $var wire 32 )! register[17] [31:0] $end
     $var wire 32 *! register[18] [31:0] $end
     $var wire 32 +! register[19] [31:0] $end
     $var wire 32 w register[1] [31:0] $end
     $var wire 32 ,! register[20] [31:0] $end
     $var wire 32 -! register[21] [31:0] $end
     $var wire 32 .! register[22] [31:0] $end
     $var wire 32 /! register[23] [31:0] $end
     $var wire 32 0! register[24] [31:0] $end
     $var wire 32 1! register[25] [31:0] $end
     $var wire 32 2! register[26] [31:0] $end
     $var wire 32 3! register[27] [31:0] $end
     $var wire 32 4! register[28] [31:0] $end
     $var wire 32 5! register[29] [31:0] $end
     $var wire 32 x register[2] [31:0] $end
     $var wire 32 6! register[30] [31:0] $end
     $var wire 32 7! register[31] [31:0] $end
     $var wire 32 y register[3] [31:0] $end
     $var wire 32 z register[4] [31:0] $end
     $var wire 32 { register[5] [31:0] $end
     $var wire 32 | register[6] [31:0] $end
     $var wire 32 } register[7] [31:0] $end
     $var wire 32 ~ register[8] [31:0] $end
     $var wire 32 !! register[9] [31:0] $end
     $var wire  5 s rs1 [4:0] $end
     $var wire 32 % rs1_data [31:0] $end
     $var wire  5 t rs2 [4:0] $end
     $var wire 32 & rs2_data [31:0] $end
     $var wire 32 - wd [31:0] $end
     $var wire  1 7 we $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#1
b00000000000000000000000000000000 #
b00000000010100000000000010010011 $
b00000000000000000000000000000000 %
b01110101111011100101001110000100 &
b00000000000000000000000000000101 '
b00000000000000000000000000000101 (
b00000000000000000000000000000101 )
b11111111111111111111111110011000 *
b00000000000000000000000000000100 +
b00000000000000000000000000000101 ,
b00000000000000000000000000000101 -
b0000 .
b0000 /
b0001 0
b000 1
b000 2
b00 3
14
05
06
07
08
09
0:
0;
1<
0=
0>
0?
0@
0A
0B
0C
0D
0E
b00000000000000000000000000000101 F
b00000000000000000000000000000000 G
b00000000000000000000000000000101 H
b00000000000000000000000000000101 I
b00000000000000000000000000000000 J
0K
0L
0M
b00 N
1O
0P
0Q
b00101 R
b00000000000000000000000000000000 S
b00000000000000000000000000000000 T
b00000000000000000000000000000000 U
b00000000000000000000000000000000 V
b00000000000000000000000000000101 W
b0010011 X
b0000000 Y
b00000000000000000000000000000101 Z
b00000000010100000000000000000000 [
b00000000000000000000000000000001 \
b00000000000000000000100000000000 ]
b00000000000000000000100000000100 ^
0_
0`
1a
0b
0c
0d
0e
1f
1g
0h
0i
0j
0k
0l
0m
0n
b000000000000101 o
b11011110111010011100111110011000 p
b0000000000000000 q
0r
b00000 s
b00101 t
b00001 u
b00100000011000110101000101110011 v
b01101010001111111000111111101010 w
b11111011000000111110100011100001 x
b10010101000011100001010001111001 y
b11001111001001110001000100000111 z
b01110101111011100101001110000100 {
b00010101111101101000000000111110 |
b01111011000001001111000110101010 }
b11010101010111001001100010110001 ~
b00011110101101010100111010110110 !!
b01001110000110100101011101011100 "!
b11111001100010001100100010010001 #!
b00001110010010100101000100110101 $!
b00100010010010010100011011000001 %!
b01101110101000100000111111000101 &!
b01010100001010010110110001000011 '!
b01111111100110001110110111100101 (!
b01011111111101011111110010000011 )!
b00000101011101100101111011010000 *!
b11101001000010010001011001000101 +!
b10111011010011101101111000000001 ,!
b11011001100100100101011100110101 -!
b00101111111010001010110111000100 .!
b10100001101001000100101011111000 /!
b10011001111111010001000101000001 0!
b01011000011001101000101111101011 1!
b10010011111011100001101001110010 2!
b11000111101011110010010000001101 3!
b10111101001011101010111000111000 4!
b11001001000000010000111100100000 5!
b01001000110111110010101001111000 6!
b00001001101110010101110100011110 7!
18!
b00000000000000000000000000001111 9!
b00000000000000000000000000100000 :!
b00000000000000000000000000010000 ;!
#2
08!
#3
b00000000000000000000000000000100 #
b00000000011000000000000100010011 $
b00010101111101101000000000111110 &
b00000000000000000000000000000110 '
b00000000000000000000000000000110 (
b00000000000000000000000000000110 )
b00000000000000000000000000001001 *
b00000000000000000000000000001000 +
b00000000000000000000000000001010 ,
b00000000000000000000000000000110 -
b00000000000000000000000000000110 F
b00000000000000000000000000000110 H
b00000000000000000000000000000110 I
b00110 R
b00000000000000000000000000000110 W
b00000000000000000000000000000110 Z
b00000000011000000000000000000000 [
b00000000000000000000000000000010 \
b00000000000000000000000000000010 ]
b00000000000000000000000000000110 ^
b000000000000110 o
b00111011001001011010101000001001 p
b0000000000000001 q
b00110 t
b00010 u
b00000000000000000000000000000101 w
18!
#4
08!
#5
b00000000000000000000000000001000 #
b01100011010101001101101011001110 $
b00011110101101010100111010110110 %
b11011001100100100101011100110101 &
b00000000000000000000000000000000 '
b00000000000000000000000000000000 (
b00011110101101010100111010110110 )
b10100110111111100000100110100011 *
b00000000000000000000000000001100 +
b00000000000000000000000000001000 ,
b00011110101101010100111010110110 -
b0101 /
b0011 0
b101 2
b00011110101101010100111010110110 F
b00011110101101010100111010110110 G
b00011110101101010100111010110110 H
b00011110101101010100111010110110 I
b00000 R
b00011110101101010100111010110110 S
b00011110101101010100111010110110 T
b00011110101101010100111010110110 U
b00011110101101010100111010110110 V
b00000000000000000000000000000000 W
b1001110 X
b0110001 Y
b00000000000000000000011000110101 Z
b01100011010101001101000000000000 [
b00000000000000000000011000110101 \
b00000000000000000000111000110100 ]
b00000000000001001101111000110100 ^
0a
0f
0g
1l
b100111010110110 o
b10100110111111100000100110100011 p
b0000000000000010 q
1r
b01001 s
b10101 t
b10101 u
b00000000000000000000000000000110 x
18!
#6
08!
#7
b00000000000000000000000000001100 #
b10010011100000111111111011110111 $
b01111011000001001111000110101010 %
b10011001111111010001000101000001 &
b01111011000001001111000110101010 )
b00010011100101000101100101100110 *
b00000000000000000000000000010000 +
b00000000000000000000000000001100 ,
b01111011000001001111000110101010 -
b0111 /
b0000 0
b111 2
b01111011000001001111000110101010 F
b01111011000001001111000110101010 G
b01111011000001001111000110101010 H
b01111011000001001111000110101010 I
b01111011000001001111000110101010 S
b01111011000001001111000110101010 T
b01111011000001001111000110101010 U
b01111011000001001111000110101010 V
b1110111 X
b1001001 Y
b11111111111111111111100100111000 Z
b10010011100000111111000000000000 [
b11111111111111111111100100111101 \
b11111111111111111111100100111100 ]
b11111111111100111111000100111000 ^
0l
1n
b111000110101010 o
b00010011100101000101100101100110 p
b0000000000000011 q
b00111 s
b11000 t
b11101 u
b00011110101101010100111010110110 -!
18!
#8
08!
#9
b00000000000000000000000000010000 #
b10010011011110010001101011010001 $
b00000101011101100101111011010000 %
b10100001101001000100101011111000 &
b00000101011101100101111011010000 )
b00000000000000000111110111010110 *
b00000000000000000000000000010100 +
b00000000000000000000000000010000 ,
b00000101011101100101111011010000 -
b0001 /
b0011 0
b001 2
b00000101011101100101111011010000 F
b00000101011101100101111011010000 G
b00000101011101100101111011010000 H
b00000101011101100101111011010000 I
b00000101011101100101111011010000 S
b00000101011101100101111011010000 T
b00000101011101100101111011010000 U
b00000101011101100101111011010000 V
b1010001 X
b11111111111111111111100100110111 Z
b10010011011110010001000000000000 [
b11111111111111111111100100110101 \
b11111111111111111111100100110100 ]
b11111111111110010001100100110110 ^
1h
0n
b101111011010000 o
b00111100110101000111110111010110 p
b0000000000000100 q
b10010 s
b10111 t
b10101 u
b01111011000001001111000110101010 5!
18!
#10
08!
